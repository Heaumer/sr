\documentclass[a4paper]{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{subfigure}

\graphicspath{ {./imgs/} }

% shorten margin
\usepackage[]{fullpage}

\title{Configuration et sécurisation de services réseaux}
\author{Mathieu BIVERT, Sophie VALENTIN}

\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1pt\hfill \kern \z@}
\def\maketitle{
	\null
	\thispagestyle{empty}
	\vskip 1cm
	\begin{center}
		\normalfont\large\huge\@author
	\end{center}
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\hrule height 2pt
	\par
	\begin{center}
				\huge \strut \@title \par
				\@date
	\end{center}
	\hrule height 2pt
	\par
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\vfil
	\begin{center}
  			\huge Professeur : Bruno MARTIN
    \end{center}
	\null
	\begin{figure}[!ht]
		\centering
		\includegraphics[scale=.5]{polytech.png}
	\end{figure}
	\vfil
	\cleardoublepage
}
\makeatother

\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage

\section{Scénario}
Serveur « public » fournissant accès distant (VPN), compte email
(postfix, dovecot, client email), espace web (apache).

Encryption autant que faire ce peut.

Logs.

Outils d'audit.

\section{Topologie}
\section{Mise en place d'une passerelle et accès à Internet}
Une passerelle (gateway) est un homme du milieu reliant
deux réseaux distincts. Dans le cas présent, la machine \textit{passerelle}
doit faire communiquer les deux réseaux SLAN (192.168.1.0/24) et LAN Travaux 
Pratiques (192.168.2.0/24).

La passerelle doit être capable de transmettre des paquets IP :
\begin{verbatim}
  (passerelle)# echo 1 > /proc/sys/net/ipv4/ip_forward
\end{verbatim}

Afin de maintenir l'\textit{IP forwarding} après un reboot de la machine
\textit{passerelle}, on décommente dans le fichier \textit{/etc/sysctl.conf}
la ligne suivante :
\begin{verbatim}
  #net.ipv4.ip_forward=1
\end{verbatim}

\vspace{1\baselineskip}
L'IP Masquerade (Network Address Translation) doit être
activée. Cette fonctionnalité modifie les entêtes IPs du trafic
passant par \textit{passerelle} afin de rendre invisibles, au niveau IP,
les machines de LAN Travaux Pratiques depuis l'extérieur.
Ici on utilise du NAT dit de source utilisant la chaîne 
\textit{POSTROUTING} puisqu'on modifie les adresses sources du paquet.
\begin{verbatim}
  (passerelle)# iptables -t nat -A POSTROUTING -o eth0 -s 192.168.2.0/24 -j MASQUERADE
\end{verbatim}

Note : L'interface \textit{eth0} est connectée au réseau SLAN.

\vspace{1\baselineskip}
Enfin, syslogd doit être activé afin de logger les activités d'iptables

\begin{verbatim}
  (passerelle)# apt-get install inetutils-syslogd
  (passerelle)# edit /etc/syslog.conf # logs dans /var/log/kernel.log
  (passerelle)# services syslog
\end{verbatim}

\subsection{Tests}
On choisit un client, par exemple \textit{client-bsd}. On lui
retire l'interface réseau connectée à SLAN \textit{em0}, et on s'assure que
la machine est bien connectée sur LAN Travaux Pratiques via \textit{em1}, et
qu'elle peut communiquer avec la passerelle. 
\begin{verbatim}
  (client-bsd)# ifconfig em0 down
  (client-bsd)# ifconfig em1
  (client-bsd)# ping passerelle.cs.sr
\end{verbatim}

\vspace{1\baselineskip}
Puis, on configure la table de routage du client afin
que la route par défaut passe par \textit{passerelle} et on vérifie :
\begin{verbatim}
  (client-bsd)# netstat -r
\end{verbatim}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.5]{Internet.png}
	\caption{\label{routes} Table de routage de \textit{client-bsd}}
\end{figure}

\vspace{1\baselineskip}
Enfin, on s'assure qu'il est possible de contacter le serveur
 et d'atteindre Internet.
\begin{verbatim}
  (client-bsd)# ping -c3 google.fr
\end{verbatim}

\vspace{1\baselineskip}
On vérifie les logs sur la passerelle:
\begin{verbatim}
  (passerelle)# tail -f /var/log/kernel.log
\end{verbatim}

nmap ? Faire peut-être une partie "outils d'attaque et... d'audit"
où on explique l'utilisation de nmap, metasploit, vas (TP de demain)
et en quoi ils nous aident à sécu notre propre réseau.

\section{Mise à disposition d'un accès distant sur la machine et sécurisation}
Telnet, SSH, VPN
Expliquer comment mettre en place TCP Wrapper avec Telnet mais pas sécurisé.
essai ssh avec mitm? (normalement il affiche un message du genre
"SOMEONE MAY BE ON THE CABLE!")

\subsection{Serveur Telnet et attaques de \textit{sniffing}}

On commence par installer un serveur \textit{telnet} afin d'offrir
un premier accès distant à la machine \textit{passerelle}.

On n'utilisera pas ici le démon classique de telnet mais un démon
générique nommé \textit{inetd} permettant de minimiser le nombre
de processus lancés. Quand \textit{inetd} reçoit une demande 
de connexion, il lance le processus serveur adéquat. 

Pour ce faire, on installe le serveur telnet.
\begin{verbatim}
  (passerelle)# apt-get install telnetd
\end{verbatim}

Puis, on modifie le fichier \textit{/etc/inetd.conf} pour y
ajouter le service \textit{telnet} dans la section des services
standard, de façon à ce qu'il soit démarré automatiquement
en tant qu'utilisateur telnetd:
\begin{verbatim}
  (passerelle)# grep '^telnet' /etc/inetd.conf
  telnet        stream    tcp nowait telnetd /usr/sbin/tcpd /usr/sbin/in.telnetd
\end{verbatim}

\vspace{1\baselineskip}
On va maintenant tenter d'intercepter le couple \textit{login/passwd}
lors d'une connexion \textit{telnet} entre \textit{client-bsd}
et \textit{passerelle}.

Pour opérer, on utilise l'outil \textit{ettercap} depuis la machine BackTrack. 
Il faut le lancer ainsi :
\begin{verbatim}
  (backtrack)# ettercap -G
\end{verbatim}

\begin{enumerate}

\item Dans le menu, on clique tout d'abord sur \textit{Sniff} et on sélectionne 
\textit{Unified sniffing} avant de choisir l'interface \textit{eth1}
qui est sur LAN Travaux Pratiques.

\item Dans le menu \textit{Hosts}, on lance un scan du réseau local puis
depuis le même menu, on affiche la liste des hôtes.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.4]{Hosts.PNG}
	\caption{\label{hosts} Hôtes détectés par le scan}
\end{figure}

On reconnaît les adresses IP de \textit{passerelle} et 
\textit{client-bsd}. Il suffit donc de spécifier que ce sont
nos deux cibles avec les boutons \textit{TARGET 1} et \textit{TARGET 2}.

\item Comme il s'agit d'un réseau commuté, on doit empoisonner les tables
ARP (\textit{ARP poisoning}) avant de lancer le \textit{sniffing} pour
récupérer le trafic entre les deux cibles.

Dans le menu \textit{Mitm}, on sélectionne donc \textit{ARP Poisoning}.

\item Enfin, on sélectionne dans le menu \textit{Start} le choix \textit{Start Sniffing}.

\end{enumerate}

La machine \textit{client-bsd} se connecte avec \textit{telnet}.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.5]{Telnet.PNG}
	\caption{\label{hosts} Connexion à \textit{passerelle}}
\end{figure}

Et on constate qu'il est extrêmement facile d'obtenir le couple \textit{login/password} en clair:

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.5]{Telnet_passwd.png}
	\caption{\label{hosts} Couple en clair}
\end{figure}

On ne veut donc pas proposer un service d'accès à distance non sécurisé, c'est-à-dire
basé sur des communications transmises en clair sur le réseau. 

 
\subsection{Serveur SSH  et optimisations}
SSH (Secure SHell) joue un rôle similaire à telnet, mais contrairement à ce
dernier, il intègre des mécanismes de sécurité, comme le chiffrement des
communications.

On installe puis démarre un serveur SSH sur la plateforme:
\begin{verbatim}
  (passerelle)# apt-get install openssh-server
  (passerelle)# service ssh start
\end{verbatim}

On teste une connexion avec mot de passe (l'option \textit{-v} est
utilisé pour montrer la différence avec une connexion à base de
clefs, voir plus bas)
\begin{verbatim}
  (client-bsd)$ ssh -v cssr@passerelle.cs.sr
  <METTRE L'OUTPUT ICI>
\end{verbatim}

Afin d'éviter d'avoir à entrer le mot de passe à chaque connexion, on peut
utiliser un système à base de clefs. On génère un couple clef privée/publique
de type RSA sur le client:
\begin{verbatim}
(client-bsd)$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/cssr/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/cssr/.ssh/id_rsa
Your public key has been saved in /home/cssr/.ssh/id_rsa
The key fingerprint is:
f4:3e:54:9f:df:eb:72:cc:7a:da:29:a5:79:58:0c:44 cssr@client-bsd
The key's randomart image is:
+--[ RSA 2048]----+
|            .E   |
|             .   |
|        .   o    |
|       . . . o . |
|        S o   =  |
|         o     =.|
|          o   O o|
|           . *.*o|
|             oX= |
+-----------------+
\end{verbatim}

Deux fichiers sont alors générés :
\begin{description}
	\item[id\_rsa.pub]	Clé publique devant être connue du serveur;
	\item[id\_rsa] 		Clé privée ne devant pas être dévoilée.
\end{description}

Côté serveur, on doit maintenant ajouter la clef publique sur le
serveur. SSH cherche dans le répertoire \textit{\$HOME/.ssh/} les
fichiers dont le nom commence par \textit{authorized\_keys}. Ceux-ci
doivent contenir une clef par ligne.

On transmet ainsi la clé publique sur le serveur, par exemple avec
\textit{scp}:
\begin{verbatim}
  (client-bsd)$ scp .ssh/id_rsa.pub cssr@passerelle.cs.sr:~/.ssh/authorized_keys2
\end{verbatim}

On prend soin d'ajuster les permissions du fichier :
\begin{verbatim}
  (passerelle)# chmod 700 authorized_keys2
\end{verbatim}
 
Enfin, on s'assure que l'authentification par clefs marche bien, et
qu'il est difficile de récupérer les informations sur la connexion
avec une attaque MITM.

La configuration du serveur SSH se fait dans le fichier \textit{/etc/ssh/sshd\_config}.
Il peut-être intéressant d'y faire les réglages suivants:
\begin{description}
	\item[X11Forwarding no] pour réduire le trafic X$11$, et donc réduire les
	risques de sécurité;
	\item[PermitRootLogin no] pour désactiver un accès distant direct au compte
	root;
	\item[Port 42], où tout autre port différent du port $22$ pour éviter les
	tentatives de connexions lancées par des bots (déni de service).
\end{description}

\subsection{Accès distant par VPN}

Alors que SSH permet l'accès sécurisé à une machine distante (le serveur SSH),
un VPN permet d'accéder au serveur VPN et à son réseau local de façon sécurisée.

On désire établir un réseau virtuel d'adresse 10.0.0.0 entre le client \textit{client-bsd} 
et le serveur \textit{passerelle}. 
On installe le paquet \textit{openvpn} sur chaque machine :
\begin{verbatim}
  (passerelle)# apt-get install openvpn
  (client-bsd)# pkg_add -r openvpn
\end{verbatim}

On effectue un premier test non chiffré.
\begin{verbatim}
  (passerelle)# openvpn --dev tun0 --ifconfig 10.0.0.1 10.0.0.2
  (client-bsd)# openvpn --remote passerelle.cs.sr --dev tun0 --ifconfig 10.0.0.2 10.0.0.1
\end{verbatim}

De chaque côté, une interface réseau \textit{tun0} apparaît : il s'agit
d'une interface "Point-à-point".
Et on fait quelques tests de connectivité dans le réseau virtuel.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.6]{Telnet_VPN.PNG}
	\caption{\label{telnet_vpn} Le serveur est accessible via son interface \textit{tun0}}
\end{figure}

\section{Configuration d'un serveur web et d'OpenSSL}
\subsection{Installation d'OpenSSL}
\begin{verbatim}
  (passerelle)# ./configure --prefix=/usr/local && make && make install
  (passerelle)# cat >> /etc/ld.so.conf
  /usr/local/openssl/lib
  ^D
  (passerelle)# ldconfig
\end{verbatim}

\subsection{Installation d'Apache2}
Après avoir récupéré les sources sur le site (et vérifié le hash du fichier), on configure
Apache avec le support d'OpenSSL
\begin{verbatim}
  (passerelle)# ./configure --option-du-chemin-ssl=/usr/local/openssl --prefix=/usr/local/apache2
  (passerelle)# /usr/local/bin/apache2/bin/apachectl start
  (passerelle)# wget http://localhost -O /dev/stdout && echo OK
\end{verbatim}

\subsection{Passage à https}

\subsection{Tests}

\section{Service de messagerie électronique et sécurisation}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.5]{emailrouting.png}
	\caption{\label{emailrouting} Un MUA envoie un email à un MTA, qui
		le forward jusqu'à un MTA final, qui le transmet à un MDA.
		Enfin, le MUA du destinataire récupère l'email depuis ce MDA}
\end{figure}

La figure \ref{emailrouting} donne un exemple simple de routage d'email,
faisant intervenir $3$ pièces logicielles:
\begin{description}
	\item[MTA] Mail Transfer Agent (eg. serveur SMTP), qui relaye les
		emails de domaines en domaines jusqu'à arriver à bonne destination;
	\item[MDA] Mail Delivery Agent (eg. serveur IMAP(s)), qui reçoit les emails
		du MTA du domaine et les délivre aux MUAs qui lui demandent;
	\item[MUA] Mail User Agent c'est le client email, dont le rôle principal
		est de récupérer les emails depuis un MDA, et d'en envoyer à un MTA;
\end{description}
D'autres agents optionnels peuvent venir s'y greffer.

En pratique, on installe et configure postfix sur \textit{passerelle}.

\subsection{Envoi et transfert d'emails avec Postfix (MTA)}

Postfix est un serveur SMTP modulaire et complexe.

On installe le paquet \textit{postfix}
\begin{verbatim}
  (passerelle)# apt-get install postfix
\end{verbatim}

Une fois le paquet installé, il faut choisir la configuration de base : on choisit
"SiteInternet" afin que Postfix crée lui-même les fichiers de configuration
dans \textit{/etc} et qu'il les remplisse de quelques directives de base.

On modifie le fichier \textit{/etc/postfix/main.cf}
\begin{verbatim}
  smtpd_banner = # On ne met rien pour ne pas donner inutilement des informations
  myhostname = passerelle.cs.sr # De préférence /etc/hostname
  mydomain = cs.sr
  alias_maps = hash:/etc/aliases
  alias_database = hash:/etc/aliases

  mynetworks = 127.0.0.0/8 # Réseaux des clients de confiance
  mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain # Domaines locaux
  inet_interfaces = all
\end{verbatim}

On prend soin d'exécuter le démon en mode \textit{debug} en modifiant 
dans \textit{/etc/postfix/master.cf} la ligne du service \textit{smtp} ainsi :
\begin{verbatim}
smtp      inet  n       -       n       -       -       smtpd -v
\end{verbatim}

Il faut ensuite relancer le démon.
\begin{verbatim}
  (passerelle)# /etc/init.d/postfix reload
\end{verbatim}

L'utilisateur \textit{alice} est ensuite ajouté. 
\begin{verbatim}
  (passerelle)# adduser alice
\end{verbatim}
Le mot de passe UNIX doit être précisé.

Un mail depuis l'utilisateur \textit{cssr} est envoyé à Alice.
\begin{verbatim}
  (passerelle)# echo "Hello" | mail -s Test alice
\end{verbatim}

On peut vérifier que Postfix est utilisé en visualisant les logs
dans \textit{/var/log/mail.log}

La livraison étant locale, l'agent "local" de \textit{postfix}
est utilisé. Ce dernier délègue la livraison des messages
à \textit{procmail}. On pourra donc lire le message dans 
\textit{/var/mail/alice}.
\begin{verbatim}
  (passerelle)# less /var/mail/alice
\end{verbatim}

Essayons d'envoyer un mail à un utilisateur qui n'existe pas : \textit{bob}.
La commande \textit{VRFY} du protocole SMTP nous indique qu'il n'existe pas.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.6]{VRFY.PNG}
	\caption{\label{verify} Résultat \textit{VRFY}}
\end{figure}
 
On tente tout de même d'envoyer un mail avec \textit{mail}. Et 
le \textit{MAILER-DAEMON} nous répond pour nous informer que
l'email n'a pas pu être envoyé.

Avec les aliases, il est possible d'indiquer à Postfix que certains
utilisateurs locaux peuvent être redirigés vers des utilisateurs
locaux voire distants.
On souhaite ici que le courrier pour Alice.Personne soit délivré
à Alice. 
Pour ce faire, on modifie les aliases dans \textit{/etc/aliases}.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.7]{Aliases.PNG}
	\caption{\label{alias} Fichier des aliases}
\end{figure}

Il faut ensuite mettre à jour les aliases.
\begin{verbatim}
  (passerelle)# postalias /etc/aliases
\end{verbatim}

Et \textit{alice} reçoit bien les messages destinés à
\textit{Alice.Personne}.

On peut noter qu'il est préférable de ne pas mettre le réseau local 192.168.1.0/24 dans
\textit{mynetworks}. Effectivement, cela considère qu'il est de confiance
et qu'on peut se passer de faire des vérifications sur le nom de domaine
des destinataires. 

\subsection{Récupération d'emails avec Dovecot (MDA) et Thunderbird (MUA)}

Nous aimerions que nos utilisateurs UNIX disposent d'un système 
leur permettant de consulter et gérer à distance leurs messages.
Le protocole IMAP offre ses fonctionnalités. 

\subsubsection{Passage au format \textit{maildir}}

On utilise \textit{maildrop} au lieu de \textit{procmail}.
L'agent \textit{maildrop} sait notamment délivrer le courrier aux dossiers au format
\textit{Maildir}. L'agent \textit{procmail} délivrait, lui, le courrier
en utilisant le format \textit{mailbox} c'est-à-dire en concaténant
tous les messages dans un même fichier. \textit{Maildir} permet
d'avoir un fichier par message.
Installons donc \textit{maildrop}
\begin{verbatim}
  (passerelle)# sudo apt-get install maildrop
\end{verbatim}

Il faut modifier la configuration de Postfix (\textit{/etc/postfix/main.cf}).
\begin{verbatim}
  mailbox_command = /usr/bin/maildrop
\end{verbatim}

On crée une boîte aux lettres par utilisateur UNIX, dans leur \$HOME.
\begin{verbatim}
  (passerelle)# cd ~
  (passerelle)# maildirmake
\end{verbatim}

Et bien sûr, on recharge la configuration de Postfix.

\subsubsection{Ajout du serveur IMAP}

On installe les paquets pour Dovecot.
\begin{verbatim}
  (passerelle)# sudo apt-get install dovecot-common
  (passerelle)# sudo apt-get install dovecot-imapd
\end{verbatim}

A l'installation, un certificat et une clé privée pour Dovecot
sont générés automatiquement. Le certificat et la clé
se trouvent respectivement dans \textit{/etc/ssl/certs/dovecot.pem}
et \textit{/etc/ssl/private/dovecot.key}. Nous les utiliserons
pour activer SSL/TLS sur le serveur IMAP.

On modifie dans \textit{/etc/dovecot/dovecot.conf} la ligne 26.
\begin{verbatim}
  listen = *
\end{verbatim}

La méthode d'authentification va être modifié dans 
\textit{/etc/dovecot/conf.d/10-auth.conf}. 
On autorise le \textit{plain text} parce que
SSL/TLS sera utilisé.
\begin{verbatim}
  disable_plaintext_auth = no # ligne 9
  auth_mechanisms = plain login # ligne 97
\end{verbatim}

Dans \textit{/etc/dovecot/conf.d/10-mail.conf}, on
définit que les dossier des messages se trouvent 
dans \textit{~/Maildir}.
\begin{verbatim}
  mail_location = maildir:~/Maildir
\end{verbatim}

Puis, dans \textit{/etc/dovecot/conf.d/10-master.conf}
pour la communication Dovecot - Postfix.
\begin{verbatim}
  # Postfix smtp-auth
  unix_listener /var/spool/postfix/private/auth { # Ligne 88
    mode = 0666
    user = postfix # à ajouter
    group = postfix # à ajouter
  } 
\end{verbatim}

On remarque dans \textit{/etc/dovecot/conf.d/10-auth.conf} que
les utilisateurs sont identifiés grâce à leurs identifiants
UNIX.

Finalement on redémarre le service \textit{dovecot}
\begin{verbatim}
  (passerelle)# service dovecot restart 
\end{verbatim}

\subsubsection{Tests IMAP depuis Thunderbird (MUA)}

On configure maintenant Thunderbird sans sécuriser la connexion
puisque le service utilisé, IMAP, n'implémente pas SSL/TLS.

A la demande de réception des messages, les identifiants
d'Alice sont demandés. Quant à l'envoi d'un message, ils ne 
nécessitent pas d'authentification.

L'email de \textit{cssr} est bien reçu par Alice.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.7]{Thunderbird.PNG}
	\caption{\label{mua} MUA}
\end{figure}

\subsubsection{Passage à IMAPS et SMTPS}

Pour utiliser des services sécurisés, on a besoin d'implémenter SSL/TLS.
On va donc mettre en place un certificat SSL.

Il a été mentionné qu'un certificat et une clé privée avaient été générés
par Dovecot. Nous allons donc les utiliser dans la suite de la configuration.
Bien entendu, on pourrait créer "à la main" le certificat \textit{mails.crt} avec les commandes
suivantes :
\begin{verbatim}
  (passerelle)# openssl genrsa -out mails.key 2048 # Clé privée
  (passerelle)# openssl req -new -days 3650 -key mails.key -out mails.csr # Demande de certificat
  (passerelle)# openssl x509 -in mails.csr -out mails.crt -req -signkey mails.key -days 3650 
\end{verbatim}
Et on pourra supprimer le fichier \textit{mails.csr} qui n'est plus utile.
On peut également utiliser le script \textit{mkcert.sh} fourni par Dovecot.

On commence par configurer Dovecot. Dans le fichier \textit{/etc/dovecot/conf.d/10-ssl.conf} :
\begin{verbatim}
  ssl = yes # Ligne 6
  ssl_cert = </etc/ssl/certs/dovecot.pem # Ligne 12
  ssl_key = </etc/ssl/private/dovecot.pem # Ligne 13
\end{verbatim}

On relance le démon Dovecot.

Puis, on configure Postfix qui va utiliser le même certificat pour SMTPS.
Dans le fichier \textit{/etc/postfix/main.cf}, il faut ajouter :
\begin{verbatim}
  smtpd_use_tls = yes
  smtpd_tls_cert_file = /etc/ssl/certs/dovecot.pem
  smtpd_tls_key_file = /etc/ssl/private/dovecot.key
  smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache
\end{verbatim}

Il faut également activer le démon \textit{smtps} dans \textit{/etc/postfix/master.cf}
et décommenter les lignes suivantes :
\begin{verbatim}
smtps     inet  n       -       -       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
\end{verbatim}

On relance Postfix.

\subsubsection{Tests IMAPS et SMTPS depuis Thunderbird (MUA)}

Cette fois-ci, on configure Thunderbird pour qu'il utilise
une connexion sécurisée pour le serveur entrant (IMAPS, port 993)
et pour le serveur sortant (SMTPS, port 465).
Dans les deux cas, on fournit un "mot de passe normal".
Avec une connexion sécurisée, on ne peut pas lire ce mot de passe même
si le mot de passe n'est pas chiffré.

\subsection{"Tunneliser" une connexion IMAP avec SSH}

Le protocole IMAP peut être sécurisée en utilisant la technique
de \textit{SSH tunneling}. En effet, SSH (qui est associé au port 22) est 
capable de chiffrer et déchiffrer le trafic d'autres applications sur
d'autres ports. SSH fournit alors un "tunnel sécurisé" à d'autres
connexions TCP/IP. 

Le serveur IMAP doit posséder un serveur SSH, ce qui est notre cas.
Depuis \textit{client-bsd}, on va mettre en place le tunnel :
\begin{verbatim}
  (client-bsd)# ssh -L2013:localhost:143 passerelle.cs.sr
\end{verbatim}

Le client de messagerie doit maintenant envoyer les données sur le port 2013
de sa propre machine. 

\subsection{Des messages chiffrés et signés avec GnuPG}

\subsubsection{Principe}

Il est bon de chiffrer les connexions, mais si les données
circulent par d'autres serveurs de courrier, le chiffrement
de la connexion n'est plus garanti. C'est pourquoi il faut 
envisager un chiffrement des données elles-mêmes. 

GnuPG permet de chiffrer et signer des messages électroniques. 
Chaque individu génère sa propre paire de clés : une publique et une privée.

On envoie sa clé publique à ses correspondants. Ces derniers pourront à 
terme nous écrire en toute confidentialité car ils chiffreront le message 
avec notre clé publique et nous
pourrons le lire grâce à notre clé privée.
Cependant, nos correspondants ne font pas encore confiance à notre clé publique. 
Ils doivent nous contacter (par un autre moyen de 
communication) pour comparer l'empreinte de la clé publique qu'ils ont reçu et l'empreinte
de notre clé publique. Une fois qu'ils ont confiance en la clé publique envoyée,
ils la signent avec leur clé secrète. 


Concernant la signature, nous appliquons notre clé privée sur le message que l'on souhaite
signer et nos correspondants (qui connaissent notre clé publique) pourront
vérifier que le message provient bel et bien de nous.

\subsubsection{Mise en pratique}

Pour simplifier l'utilisation de GnuPG, on utilise le plugin \textit{Enigmail} pour le MUA
\textit{Thunderbird}. Et on crée une paire de clés (et un certificat de révocation)
pour l'utilisateur \textit{alice} mais aussi pour l'utilisateur \textit{cssr}.

% --keyserver pour mettre la clef sur un serveur ... de clefs :-)
% http://wxcafe.net/archives/27

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=.5]{pgp.png}
	\caption{\label{pgp} L'utilisateur \textit{cssr} reçoit un message d'Alice qui avait été signé et chiffré}
\end{figure}

\section{Outils d'audit : OpenVAS \& Metasploit}

\section{Politique de sécurité : Flux autorisés}

Mettre règles de Firewall pour tous les services proposés.

\end{document}
